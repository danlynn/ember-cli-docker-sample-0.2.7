#!/usr/bin/env ruby

require 'yaml'
require 'erb'
require 'json'
require 'open3'
require 'net/http'
require 'uri'


# Used to ensure that .project.yml file format matches this script
VERSION = '1.0.0'


# Making a inetd-style service for systemd:
#   http://0pointer.de/blog/projects/inetd.html
# watchman docs:
#   https://facebook.github.io/watchman/docs/

# watchman -j <<-EOT
# ["trigger", "/Users/danlynn/Documents/JavaScript/Projects/ember-cli-docker-sample-0.2.3-2", {
#   "name": "trigger_rebuild",
#   "expression": ["allof",
#     ["anyof",
#       ["match", "app/*", "wholename"],
#       ["match", "test/*", "wholename"]
#     ],
#     ["type", "f"]
#   ],
#   "stdin": ["name"],
#   "command": ["/Users/danlynn/Documents/JavaScript/Projects/ember-cli-docker-sample-0.2.3-2/trigger_rebuild.rb"]
# }]
# EOT


# Note that the watchman log can be determined by appending
# '.log' to the 'sockname' value returned from:
#   $ watchman get-sockname
#
# TODO: Install project in path for access anywhere (for 'project init')
# TODO: Ask to permanently copy in private key for github access to private repos
#       + docker run -t -i --name test1 ubuntu:14.04v2 project.rb install_ssh_key key_name
#       + ...also copy ~/.ssh/known_hosts file
#       + echo 'IdentityFile ~/.ssh/github' > ~/.ssh/config
#         then when prompted "Enter passphrase for key '/root/.ssh/github':" enter passphrase
#       + docker commit -m "added /root/test.txt file" -a "danlynn" test1 ubuntu:14.04v2
#       + Need to install an ssh user agent to remember passphrase for ssh
#
#
# Commands:
#
# project
#   + starts an interactive mode that displays a menu of actions.
#     Maybe it displays the project status followed by these basic
#     commands.
#       1. start
#       2. stop
#       3. rebuild
#       4. setup
# project status
#   + displays the status of the vm and services:
#
#       Project:
#         path: projects/myapp
#         docker-machine:
#           name:   dev3
#           status: running
#         services:
#           db:     running
#           rails:  running
#           ember:  stopped
#
# project init
#   + asks if you want to update current project if .project_* files already exist
#   + creates the .project.yml via interactive prompts (dm_name, etc.)
#   + appends call to .project.sh to .rvmrc or creates it if it doesn't exist
# project activate
#   + this is called by .rvmrc upon entering dir tree
#   + setup the command proxies: ember, npm, bower
#   + configures docker: eval "$(docker-machine env #{dm_name})"
# project start
#   + calls 'project setup' in case rvm is not installed
#   + start preferred docker-machine if not already running
#   + start the services (docker-compose up)
#   + track what new docker container appears in 'docker ps' and save container
#     id for use by 'project rebuild'
#   + open root route in default browser
# restart
#   + stop then start the docker-compose container
# project rebuild
#   + trigger an immediate rebuild by bouncing the ember server
# project stop
#   + stop the services (docker-compose stop)
#   + de-register the watchman trigger
#   + stop the docker-machine if no other docker-compose processes are running
#     (via docker ps not showing any running processes for that vm)
# project browse
#   + open root route in default browser
# project setup share
#   + verify and configure both OSX host and boot2docker vm to use either native
#     vm sharing or nfs sharing for the project dir. Interactive prompt will
#     prompt for config options.


# === utility methods ===

# Get the root_dir of the project by looking for the project.yml file in
# the current directory and then traversing the parent dir hierarchy until it
# is found.
def root_dir
  return @root_dir if @root_dir
  dir = Dir.pwd
  begin
    return @root_dir = dir if File.exist?(File.join(dir, '.project.yml'))
    dir = File.dirname(prev_dir = dir)
  end while dir != prev_dir
  raise 'ERROR: No project root_dir found (containing .project.yml file)'
end


def project_config
  unless @project_config
    @project_config = YAML.load(ERB.new(File.read(File.join(root_dir,'.project.yml')), nil, "%<>").result(binding))
    @project_config['watchman']['log_path'] = JSON.parse(`watchman get-sockname`)['sockname'] + '.log'
  end
  @project_config
end


# Get the string that should be prepended to any sub-shell command that will
# make sure that docker is configured for this project's docker-machine.
def setup_docker_env_vars_str
  "eval \"$(docker-machine env #{project_config['docker-machine']['name']})\" && "
end


# Get the standard docker container name generated by docker-compose for the
# specified 'service'.
def container_name(service)
  File.basename(root_dir).gsub(/\W/, '') + "_#{service}_1"
end


# Determine if the vm is running
def vm_running?
  `docker-machine ls | grep #{project_config['docker-machine']['name']}` =~ /running/i ? true : false
end


def wait_until_vm_pingable
  stdin, stdout = Open3.popen2("ping #{docker_machine_ip}")
  30.times do
    break if stdout.gets.chomp =~ /^\d+ bytes from [0-9.]+:/
  end
  stdin.close
  stdout.close
end


def wait_until_docker_daemon_responding
  15.times do
    sleep(2)
    # TODO: replace hard-coded image using docker-compose.yml
    stdout_data, stderr_data = Open3.capture3("#{setup_docker_env_vars_str} docker run --entrypoint echo danlynn/ember-cli:0.2.7 responding")
    return if stdout_data =~ /responding/
  end
end


# get the number of running containers in the current docker-machine
def running_container_count
  `#{setup_docker_env_vars_str} docker ps`.split("\n").size - 1
end


# Determine if the docker-compose service identified in project_config.yml at
# docker-compose > service is running.
def service_running?
  response = `#{setup_docker_env_vars_str} docker-compose ps #{project_config['docker-compose']['service']}`
  return false if response =~ /No such service/i
	service_state = response.split("\n")[2].split(/\s{2,}/)[2]
	service_state =~ /up/i ? true : false
end


def browser_url_responding?
  url = project_config['browser']['url'].gsub('{{docker-machine ip}}', docker_machine_ip)
  uri = URI.parse(url)
  http = Net::HTTP.new(uri.host, uri.port)
  request = Net::HTTP::Get.new(uri.request_uri)
  response = http.request(request)
  response.code == '200'
rescue
  false
end


def docker_machine_ip
  `#{setup_docker_env_vars_str} docker-machine ip`.chomp
end


def open_webapp
  if project_config['browser'] && project_config['browser']['url']
    path = project_config['browser']['path']
    url = project_config['browser']['url'].gsub('{{docker-machine ip}}', docker_machine_ip)
    `open #{path ? "-a '#{path}'" : ''} '#{url}'`
  end
end


# === watchman trigger utility methods ===

# Get list of watchman trigger for the project root_dir.  Note that this may
# contain triggers that the user registered outside of the one managed by this
# project.
def watchman_triggers
  JSON.parse(`watchman trigger-list #{root_dir}`)['triggers'] || []
end


# Determine if watchman trigger named 'trigger_rebuild' is currently installed
# for the project root_dir
def watchman_trigger_installed?
  watchman_triggers.any?{|trigger| trigger['name'] == 'trigger_rebuild'}
end


# Adds watchman trigger to call 'project rebuild' when any files in the
# config's watchman > directories are modified.  If the trigger already exists
# then no additional trigger will be added.
def add_watchman_trigger
  unless watchman_trigger_installed?
    matches = project_config['watchman']['directories'].collect{|dir| "[\"match\",\"#{dir}\",\"wholename\"]"}.join(',')
    json = <<-EOJ
      ["trigger", "#{root_dir}", {
        "name": "trigger_rebuild",
        "expression": ["allof",
          ["anyof",
            #{matches}
          ],
          ["type", "f"]
        ],
        "stdin": ["name"],
        "command": ["#{root_dir}/project.rb","rebuild"]
      }]
    EOJ
    stdout_data, stderr_data = Open3.capture3("watchman -j", :stdin_data => json)
    return JSON.parse(stdout_data)['disposition'] == 'created'
  end
  false # no trigger installed
end


# Removes the watchman trigger that calls 'project build'.  This is useful for
# the 'project stop' command.  It is also useful when it is determined that the
# container or vm are no longer running.
def remove_watchman_trigger
  if watchman_trigger_installed?
    `watchman trigger-del #{root_dir} 'trigger_rebuild'`
  end
end


# === command methods ===

# Retrieve config property by passing the project_config path as an array of
# String names. For example: config('docker-machine','name')
#
# @param path_elements [Array<String>] hierarchy of path names
def config(path_elements)
  path_elements.inject(project_config){|reduction, path_element| reduction[path_element]} rescue nil
end


#   + prompt user to fill in values needed to create
#     + .project.yml
#     + .project.sh
#     + docker-compose.yml
#     + docker-compose-dev.yml
#     + README-project.md
#     + .rvmrc
#   + check that docker-machine, docker-compose, docker installed
#   + check that at least 1 docker-machine has been created
def init

end


#   + calls 'project setup' in case rvm is not installed
#   + start preferred docker-machine if not already running
#   + start the services (docker-compose up)
#   + open root route in default browser
def start
  # TODO: if .project.yml and .sh have not been created yet then call init to make them
  puts "\n\n  project:"
  puts '    command:   start'
  puts "    name:      #{File.basename(root_dir)}"
  puts "\n  docker-machine:"
  puts "    name:      #{project_config['docker-machine']['name']}"
  unless vm_running?
    print "    status:    starting...\r"
    `docker-machine start #{project_config['docker-machine']['name']}` #  > /dev/null 2>&1
  end
  if vm_running?
    puts '    status:    running                              '
  else
    puts '    status:    failed to start                      '
    exit 0
  end
  puts "\n  watchman:"
  unless watchman_trigger_installed?
    print "    trigger:   installing...\r"
    add_watchman_trigger
  end
  puts "    trigger:   #{watchman_trigger_installed? ? 'installed' : 'not installed'}          "
  fork do
    30.times do
      sleep(1)
      if browser_url_responding?
        open_webapp
        break
      end
    end
    exit 0
  end
  puts "\n  docker-compose:"
  puts "    service:   #{project_config['docker-compose']['service']}"
  unless service_running?
    print "    status:    waiting on docker daemon...\r"
    wait_until_docker_daemon_responding # TODO: flip this to before the service_running? check
    puts "    status:    starting...                 \n\n"
    puts "    note: browser will open webapp as soon as service is ready\n\n"
    puts "    tip: execute 'docker-compose logs' to tail the service logs\n\n"
    exec("#{setup_docker_env_vars_str} docker-compose start")
    # stdout_data, stderr_data = Open3.capture3("#{setup_docker_env_vars_str} docker-compose start")
    # 20.times do
    #   sleep(1)
    #   break if service_running?
    # end
  else
    puts '    status:    running'
  end
  # puts "    status:    #{service_running? ? 'running' : 'failed to start'}          "
end


#   + stop the services (docker-compose stop)
#   + de-register the watchman trigger
#   + stop the docker-machine if no other docker-compose processes are running
#     (via docker ps not showing any running processes for that vm)
def stop
  puts "\n\n  project:"
  puts '    command:   stop'
  puts "    name:      #{File.basename(root_dir)}"
  unless vm_running?
    puts "\n  docker-machine:"
    puts "    name:      #{project_config['docker-machine']['name']}"
    puts '    status:    ALREADY stopped'
    puts "\n\n  docker-machine not even running - thus nothing to do\n\n"
  else
    puts "\n  docker-compose:"
    puts "    service:   #{project_config['docker-compose']['service']}"
    unless service_running?
      puts '    status:    ALREADY stopped'
      puts "\n\n  service not even running - thus nothing to do\n\n"
    else
      print "    status:    stopping...\r"
      `#{setup_docker_env_vars_str} docker-compose stop > /dev/null 2>&1`
      puts '    status:    stopped          '
      puts "\n  watchman:"
      if watchman_trigger_installed?
        print "    trigger:   removing...\r"
        remove_watchman_trigger
      end
      puts "    trigger:   #{watchman_trigger_installed? ? 'still installed' : 'removed'}          "
      if running_container_count == 0
        puts "\n  docker-machine:  (no containers running)"
        puts "    name:      #{project_config['docker-machine']['name']}"
        print "    status:    stopping...\r"
        `#{setup_docker_env_vars_str} docker-machine stop #{project_config['docker-machine']['name']}`
        puts "    status:    stopped            \n\n"
      end
    end
  end
end


# Restarts the service container if it is currently running.  If the container
# or the docker-machine aren't running then a regular 'project start' is
# performed.
def restart
  puts "\n\n  project:"
  puts '    command:   restart'
  puts "    name:      #{File.basename(root_dir)}"
  puts "\n  docker-machine:"
  puts "    name:      #{project_config['docker-machine']['name']}"
  unless vm_running?
    puts '    status:    NOT running                      '
    puts "\n\n  docker-machine not even running - thus do regular start\n\n"
    start
  else
    puts '    status:    running                              '
    puts "\n  docker-compose:"
    puts "    service:   #{project_config['docker-compose']['service']}"
    unless service_running?
      puts '    status:    NOT running                      '
      puts "\n\n  service not even running - thus do regular start\n\n"
      start
    else
      puts "    status:    restarting...                 \n\n"
      exec("#{setup_docker_env_vars_str} docker-compose restart")
    end
  end
end


# Consumes watchman trigger json from stdin when called as trigger.  Note that
# the actions of this trigger are logged to the watchman log which can be found
# by running 'watchman get-sockname' then using the 'sockname' attribute in the
# response and appending '.log' to it.
# TODO: detect failed response to docker exec and remove trigger if vm or container stopped
def rebuild
  # default to no paths
  triggered_paths = STDIN.tty? ? [] : eval($stdin.read)
  puts "\n\nProject command: rebuild"
  puts "\n  project root: #{root_dir}"
  puts "\n  triggered by:"
  triggered_paths.each{|path| puts "    #{path}"}
  # triggered_paths: files that invoked the trigger
  # modifed_paths:   files modified since previous 'watchman since' query
  # touched_paths:   files modified by running the docker touch command
  query = "watchman since . n:mod 'app/*' 'test/*'"
  modified_paths = JSON.parse(`#{query}`)['files'].collect{|file| file['name']}.select{|file| File.file?(file)}
  modified_paths = triggered_paths & modified_paths # handle first-run
  puts "\n  actually modified:"
  if modified_paths.size > 0
    modified_paths.each{|path| puts "    #{path}"}
    puts "\n  rebuild: triggered"
    # TODO: display notification center message when 'docker exec' fails to remind them to run 'project stop'
    `#{setup_docker_env_vars_str} docker exec #{container_name(project_config['docker-compose']['service'])} touch -c #{modified_paths.collect{|path| "'#{path}'"}.join(' ')}`
    # `#{dm_env} docker run --entrypoint /usr/bin/touch -v $(pwd):/myapp danlynn/ember-cli:0.2.3 #{modified_paths.join(' ')}`
    touched_paths = JSON.parse(`#{query}`)['files'].collect{|file| file['name']}.select{|file| File.file?(file)}
    puts "    touched #{touched_paths.size} of #{modified_paths.size} files"
  else
    puts '    none'
    puts "\n  rebuild: skipped"
  end
  puts "\n  complete\n\n\n"
end


def docker_exec(args)
  # exec ("docker exec -i -t #{container_name(project_config['docker-compose']['service'])} #{args.join(" ")}")
  exec ("#{setup_docker_env_vars_str} docker exec -i -t #{container_name(project_config['docker-compose']['service'])} #{args.join(" ")}")
end


# Display project status:
#
#   project:
#     name:    root_dir_name
#
#   docker-machine:
#     name:    dm_name
#     status:  vm_running?
#
#   service:
#     name:    service_name
#     command: service_command
#     status:  server_running
#
#   watchman:
#     trigger: watchman_trigger_installed?
def status
  vm_running = vm_running?
  puts "\n\n  project:"
  puts '    command:   status'
  puts "    name:      #{File.basename(root_dir)}"
  puts '    env:       .project.sh'
  puts '    config:    .project.yml'
  puts "\n  docker-machine:"
  puts "    name:      #{project_config['docker-machine']['name']}"
  puts "    status:    #{vm_running ? 'running' : 'stopped'}"
  puts "\n  docker-compose:"
  puts "    service:   #{project_config['docker-compose']['service']}"
  if vm_running
    response = `#{setup_docker_env_vars_str} docker-compose ps #{project_config['docker-compose']['service']}`
    if response =~ /No such service/i
      puts "    status:    stopped"
    else
      service_name, service_command, service_state = response.split("\n")[2].split(/\s{2,}/)
      puts "    status:    #{service_state =~ /up/i ? 'running' : 'stopped'}"
      puts "    container: #{container_name(project_config['docker-compose']['service'])}"
      puts "    command:   #{service_command}"
    end
  else
    puts "    status:    stopped"
  end
  puts "\n  watchman:"
  puts "    trigger:   #{watchman_trigger_installed? ? 'installed' : 'not installed'}"
  puts "    log:       #{project_config['watchman']['log_path']}"
  puts "\n\n"
end


# === main ===

case ARGV[0]
  when 'start'
    start
  when 'restart'
    restart
  when 'stop'
    stop
  when 'rebuild'
    rebuild
  when 'status'
    status
  when 'config'
    puts config(ARGV[1..-1])
  when 'vm_running'
    puts 1 if vm_running?
  when 'docker_exec'
    docker_exec(ARGV[1..-1])
end
